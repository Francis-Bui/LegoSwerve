#pragma config(Sensor, dgtl1,  myEncoder,        sensorQuadEncoder)S
//#pragma config(Motor,  port10, myMotor,    tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// PID using optical shaft encoder
//
// Shaft encoder has 360 pulses per revolution


// These could be constants but leaving
// as variables allows them to be modified in the debugger "live"
//float  pid_Kp = 2.0;
//float  pid_Ki = 0.04;
//float  pid_Kd = 0.0;

static float pidRequestedValue;


/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  pid control task                                                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

struct PIDController{
	float pidIntegral;
	float pidDerivative;
	float pidDrive;
	float pidLastError;

	float maxOutput;
	float minOutput;

	float kP;
	float kI;
	float kD;

	float integralLimit;
}

void initPIDConstants(struct PIDController *controller, float p, float i, float d)
{
	controller -> kP = p;
	controller -> kI = i;
	controller -> kD = d;
}

void initOutputRange(struct PIDController *controller, float max, float min)
{
	controller -> maxOutput = max;
	controller -> minOutput = min;
}


void reset(struct PIDController *controller)
{
	controller -> pidLastError = 0;
	controller -> pidIntegral = 0;
	controller -> pidDerivative = 0;
}

float PID_calculateDrive(struct PIDController *controller, float error)
{
		float integral = controller -> pidIntegral;
		float derivative = controller -> pidDerivative;
		float lastError = controller -> pidLastError;
		float drive;

		if(controller -> kI != 0 && abs(error) < controller -> integralLimit)
			integral += error;
	  else
	  	integral = 0;
		controller -> pidIntegral = integral;

	  derivative = error - lastError;
	  controller -> pidLastError = error;

	  drive = (controller -> kP)*error + (controller -> kI)*integral + (controller -> kD)*derivative;
	  if(drive > controller -> maxOutput)
	  	drive = controller -> maxOutput;

	  if (drive < controller -> minOutput)
	  	drive = controller -> minOutput;

	  return drive;
}


task motorPIDController()
{
    while(true)
    {
    	// Run at 50Hz
      wait1Msec( 25 );
    }
}

task main()
{
    // send the motor off somewhere
    pidRequestedValue = 1000;

    // start the PID task
    startTask(motorPIDController);
}
